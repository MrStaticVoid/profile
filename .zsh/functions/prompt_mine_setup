#
# prompt_mine
#
# A custom Powerline-style prompt that dynamically shows information as
# needed to ensure the most important context information in the least
# amount of space as possible.
#

prompt_mine_separator() {
    local bg=$1

    if [[ -n $sep_fg ]]; then
        if [[ $flat != true ]]; then
            if [[ $sep_fg == $bg ]]; then
                print -n "%{${mycolors_bg[$bg]}${mycolors_fg[base01]}%}%{${reset_color}%}"
            else
                print -n "%{${mycolors_bg[$bg]}${mycolors_fg[$sep_fg]}%}%{${reset_color}%}"
            fi
        fi
    fi

    sep_fg=$bg
}

prompt_mine_segment() {
    local content=$1
    local bg=$2
    local fg=$3
    local bold=$4

    if [[ $flat == true && -z $content ]]; then
        content='>'
        fg=$bg
        bg=default
        bold=true
    fi

    prompt_mine_separator $bg
    [[ -n $bold ]] && print -n '%B'
    print -n "%{${mycolors_bg[$bg]}${mycolors_fg[$fg]}%}${content}%{${reset_color}%}"
    [[ -n $bold ]] && print -n '%b'
}

prompt_mine_username() {
    if [[ ! $(print -P '%n') =~ $hide_users ]]; then
        prompt_mine_segment ' %n ' blue black bold
    fi
}

prompt_mine_hostinfo() {
    local content='%m'

    if [[ $flat != true ]]; then
        content=" ${content} "
    fi

    if [[ -n $SSH_CLIENT ]]; then
        prompt_mine_segment $content base02 default bold
    fi
}

prompt_mine_cwd() {
    local cwd=$1
    local formatted
    local -a components

    # Split at /
    components=(${(s:/:)cwd})

    if [[ ${#components} > 1 ]]; then
        if [[ ${components[1]} != '~' ]]; then
            formatted='/'
        fi

        formatted+="${(j:/:)components[1,-2]}/%B${components[-1]}"
    else
        formatted="%B${cwd}"
    fi

    prompt_mine_segment " ${formatted} " base01

    # unset bold
    print -n '%b'
}

prompt_mine_ro() {
    local content

    if [[ $flat == true ]]; then
        content=" RO "
    else
        content="  "
    fi

    if [[ ! -w . ]]; then
        prompt_mine_segment $content yellow base01
    fi
}

prompt_mine_bg() {
    if [[ $(jobs | wc -l) -gt 0 ]]; then
        prompt_mine_segment ' %j ' green base01
    fi
}

prompt_mine_userinfo() {
    if [[ $root == true ]]; then
        prompt_mine_segment '' red
    fi

    if [[ $admin == true ]]; then
        prompt_mine_segment '' base09
    fi
}

prompt_mine_vimode() {
    if [[ $KEYMAP = 'vicmd' ]]; then
        prompt_mine_segment '' blue
    else
        prompt_mine_segment '' green
    fi
}

prompt_mine_end() {
    prompt_mine_separator
}

prompt_mine_build_prompt() {
    local uniq_cwd=$1

    prompt_mine_username
    prompt_mine_hostinfo
    prompt_mine_cwd $uniq_cwd
    prompt_mine_ro
    prompt_mine_bg
    prompt_mine_userinfo
    prompt_mine_vimode
    prompt_mine_end
}

prompt_mine_disambiguate_cwd() {
    local admin_title

    disambiguate -k "$(print -P "%~")"
    uniq_cwd=$REPLY

    if [[ $admin == true ]]; then
        admin_title='/admin'
    fi

    # Set terminal title
    case $TERM in
        xterm*|screen*)
            print -Pn "\e]0;%n${admin_title}@%m:${uniq_cwd}\a"
            ;;
    esac
}

function zle-line-init zle-keymap-select {
    [[ -n $uniq_cwd ]] || prompt_mine_disambiguate_cwd
    PROMPT="$(prompt_mine_build_prompt $uniq_cwd) "
    zle reset-prompt
}

prompt_mine_setup() {
    autoload -U disambiguate
    autoload -U colors && colors

    typeset -Ax mycolors_bg mycolors_fg
    mycolors_bg=(${(kv)bg})
    mycolors_fg=(${(kv)fg})

    integer color_code=0
    for color in black red green yellow blue magenta cyan white; do
        if [[ $terminfo[colors] -lt 16 ]]; then
            # We don't have "bright colors"...use regular instead
            mycolors_bg[br-${color}]=$bg[$color]
            mycolors_fg[br-${color}]=$fg[$color]
        else
            mycolors_bg[${color}]="\e[48;5;${color_code}m"
            mycolors_fg[${color}]="\e[38;5;${color_code}m"
            mycolors_bg[br-${color}]="\e[48;5;$((color_code + 8))m"
            mycolors_fg[br-${color}]="\e[38;5;$((color_code++ + 8))m"
        fi
    done

    # While Konsole doesn't support setting all the Base16 colors
    # (https://bugs.kde.org/show_bug.cgi?id=344181), manually define
    # the ones we want to use from the base16-bright theme.
    # See: https://gist.github.com/XVilka/8346728
    # See: https://github.com/chriskempson/base16-builder/blob/master/schemes/bright.yml
    if [[ $terminfo[colors] -ge 256 ]]; then
        mycolors_bg[base01]="\e[48;2;48;48;48m"
        mycolors_fg[base01]="\e[38;2;48;48;48m"
        mycolors_bg[base02]="\e[48;2;80;80;80m"
        mycolors_fg[base02]="\e[38;2;80;80;80m"
        mycolors_bg[base03]="\e[48;2;176;176;176m"
        mycolors_fg[base03]="\e[38;2;176;176;176m"
        mycolors_bg[base09]="\e[48;2;252;109;36m"
        mycolors_fg[base09]="\e[38;2;252;109;36m"
    else
        mycolors_bg[base09]="$mycolors_bg[yellow]"
        mycolors_fg[base09]="$mycolors_fg[yellow]"
    fi

    zstyle -s ':prompt:mine' hide-users hide_users
    zstyle -s ':prompt:mine' root root
    zstyle -s ':prompt:mine' admin admin
    zstyle -s ':prompt:mine' flat flat

    add-zsh-hook chpwd prompt_mine_disambiguate_cwd
    zle -N zle-line-init
    zle -N zle-keymap-select
}

prompt_mine_setup "$@"

# vim: filetype=zsh
