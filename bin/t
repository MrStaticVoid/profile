#!/usr/bin/env zsh
#
# Intelligent tmux helper
#
# This is sort of like a t=tmux alias in that it can be used in almost
# the same way as tmux to run tmux commands; but it also falls back to
# session creation/attachment if the command doesn't exist.  And if no
# arguments are passed, then a session is created/attached based on the
# hostname.  So:
#
#   t ls
#
# lists sessions;
#
#   t foo
#
# creates and/or attaches a session called 'foo'; and
#
#   t
#
# creates and/or attaches to a session called $HOST.
#
# This also has additional functionality to automatically update an
# existing server's AFS tokens, run the server in a separate scope when
# systemd is available so it doesn't get killed on logout, and run
# safely and intuitively inside a tmux session.
#

if [[ ! -x $(whence tmux) ]]; then
    print "tmux is not installed" >&2
    exit 1
fi

tmux_commands=($(TMUX='' tmux list-commands | gawk '{ gsub("[()]", "", $2); print $1; print $2 }'))

exec_tmux() {
    if tmux list-sessions > /dev/null 2>&1; then
        if [[ ! $TMUX ]]; then
            tmux set-environment -g TERM "$TERM"

            # All of this is just to say: if we have a Kerberos ticket, and
            # it's different from the running tmux environment, then update the
            # tmux environment and run aklog if available.  Otherwise, we don't
            # have a Kerberos ticket, so remove it from the tmux environment.
            # The session environment is updated rather than the global
            # environment because 1) it is easier to refresh the shell
            # environment from the tmux session environment, and 2) session
            # variables take precedence over global variables for commands run
            # with 'tmux run-shell'.
            if [[ $KRB5CCNAME ]]; then
                local real_krb5ccname="$KRB5CCNAME"
                eval "$(tmux show-environment -s KRB5CCNAME)"
                if [[ $real_krb5ccname != $KRB5CCNAME ]]; then
                    tmux set-environment KRB5CCNAME "$KRB5CCNAME"
                    if [[ -x $(whence aklog) ]]; then
                        tmux run-shell aklog
                    fi
                fi
            else
                tmux set-environment -r KRB5CCNAME
            fi
        fi
    elif systemctl --user > /dev/null 2>&1; then
        systemctl --user stop tmux.scope 2>/dev/null
        exec systemd-run --user --scope --unit tmux tmux "$@"
    fi

    exec tmux "$@"
}

tmux_new_session() {
    local name="$1"
    shift

    if [[ $TMUX ]]; then
        tmux new-session -d -s "$name" "$@" 2>/dev/null

        # When running outside of tmux, new-session has the ability to detach
        # all clients currently attached to the session if it already exists.
        # When running inside of tmux, that flag doesn't work, so the following
        # detects when '-D' is passed, removes '-D' from the list of arguments,
        # and detaches the other clients explicitly.
        local -a detach
        zparseopts -D -E D=detach
        if [[ $detach ]]; then
            local self="$(tmux display-message -p '#{client_tty}')"
            for client in $(tmux list-clients -F '#{client_tty}' -t "$name" | grep -F -v "$self"); do
                tmux detach-client -t "$client"
            done
        fi

        tmux switch-client -t "$name"
    else
        exec_tmux new-session -A -s "$name" "$@"
    fi
}

if (( ARGC == 0 )); then
    tmux_new_session "${HOST%%.*}"
elif (( tmux_commands[(I)${1}*] )) || [[ $1 == -* ]]; then
    exec_tmux "$@"
else
    tmux_new_session "$@"
fi
